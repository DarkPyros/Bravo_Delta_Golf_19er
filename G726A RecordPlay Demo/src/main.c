/**************************************************************************
*  
*             ITU-T SOFTWARE TOOLS' GENERAL PUBLIC LICENSE                  
*
*  This "General Public License" is published in the Annex 1 of the
*  ITU-T Recommendation on "SOFTWARE TOOLS FOR HOMOGENITY OF RESULTS
*  IN THE STANDARDIZATION PROCESS OF SPEECH AND AUDIO CODERS",
*  approved in Geneva, 2000.
*
*  TERMS AND CONDITIONS
*
*  1. This License Agreement applies to any module or other work
*  related to the ITU-T Software Tool Library, and developed by the
*  User's Group on Software Tools. The "Module", below, refers to any
*  such module or work, and a "work based on the Module" means either
*  the Module or any work containing the Module or a portion of it,
*  either verbatim or with modifications.  Each licensee is addressed
*  as "you".
*
*  2. You may copy and distribute verbatim copies of the Module's
*  source code as you receive it, in any medium, provided that you:
*  -  conspicuously and appropriately publish on each copy an appropriate
*     copyright notice and disclaimer of warranty;
*  -  keep intact all the notices that refer to this General Public
*     License and to the absence of any warranty; and
*  -  give any other recipients of the Module a copy of this General
*     Public License along with the Module.
*  You may charge a fee for the physical act of transferring a copy.
*
*  3. You may modify your copy or copies of the Module or any portion
*  of it, and copy and distribute such modifications under the terms
*  of Paragraph 1 above, provided that you also do the following:
*
*      o  cause the modified files to carry prominent notices stating
*      that you changed the files and the date of any change; and
*
*      o  cause the whole of any work that you distribute or publish,
*      that in whole or in part contains the Module or any part
*      thereof, either with or without modifications, to be licensed
*      at no charge to all third parties under the terms of this
*      General Public License (except that you may choose to grant
*      warranty protection to some or all third parties, at your
*      option).
*
*      o  If the modified module normally reads commands interactively
*      when run, you must cause it, when started running for such
*      interactive use in the simplest and most usual way, to print or
*      display an announcement including an appropriate copyright
*      notice and a notice that there is no warranty (or else, saying
*      that you provide a warranty) and that users may redistribute
*      the module under these conditions, and telling the user how to
*      view a copy of this General Public License.
*
*  You may charge a fee for the physical act of transferring a copy,
*  and you may at your option offer warranty protection in exchange
*  for a fee.
*
*  Mere aggregation of another independent work with the Module (or
*  its derivative) on a volume of a storage or distribution medium
*  does not bring the other work under the scope of these terms.
*
*  4.  You may copy and distribute the Module (or a portion or
*  derivative of it, under Paragraph 2) in object code or executable
*  form under the terms of Paragraphs 1 and 2 above provided that you
*  also do one of the following:
*
*      o  accompany it with the complete corresponding machine-
*      readable source code, which must be distributed under the terms
*      of Paragraphs 1 and 2 above; or,
*
*      o  accompany it with a written offer, valid for at least three
*      years, to give any third party free (except for a nominal
*      charge for the cost of distribution) a complete machine-
*      readable copy of the corresponding source code, to be
*      distributed under the terms of Paragraphs 1 and 2 above; or,
*
*      o  accompany it with the information you received as to where
*      the corresponding source code may be obtained.  (This
*      alternative is allowed only for noncommercial distribution and
*      only if you received the module in object code or executable
*      form alone.) 
*
*  Source code for a work means the preferred form of the work for
*  making modifications to it.  For an executable file, complete
*  source code means all the source code for all modules it contains;
*  but, as a special exception, it need not include source code for
*  modules which are standard libraries that accompany the operating
*  system on which the executable file runs, or for standard header
*  files or definitions files that accompany that operating system.
*
*  5.  You may not copy, modify, sublicense, distribute or transfer
*  the Module except as expressly provided under this General Public
*  License. Any attempt otherwise to copy, modify, sublicense,
*  distribute or transfer the Module is void, and will automatically
*  terminate your rights to use the Module under this License. 
*  However, parties who have received copies, or rights to use copies,
*  from you under this General Public License will not have their
*  licenses terminated so long as such parties remain in full
*  compliance.
*
*  6.  By copying, distributing or modifying the Module (or any work
*  based on the Module) you indicate your acceptance of this license
*  to do so, and all its terms and conditions.
*
*  7.  Each time you redistribute the Module (or any work based on the
*  Module), the recipient automatically receives a license from the
*  original licensor to copy, distribute or modify the Module subject
*  to these terms and conditions.  You may not impose any further
*  restrictions on the recipients' exercise of the rights granted
*  herein.
*
*  8.  The ITU-T may publish revised and/or new versions of this
*  General Public License from time to time.  Such new versions will
*  be similar in spirit to the present version, but may differ in
*  detail to address new problems or concerns.
*
*  Each version is given a distinguishing version number. If the
*  Module specifies a version number of the license which applies to
*  it and "any later version", you have the option of following the
*  terms and conditions either of that version or of any later version
*  published by the ITU-T. If the Module does not specify a version
*  number of the license, you may choose any version ever published by
*  the ITU-T.
*
*  9.  If you wish to incorporate parts of the Module into other free
*  modules whose distribution conditions are different, write to the
*  author to ask for permission.  For software which is copyrighted by
*  the ITU-T, write to the ITU-T Secretariat; exceptions may be made
*  for this. This decision will be guided by the two goals of
*  preserving the free status of all derivatives of this free software
*  and of promoting the sharing and reuse of software generally.
*
*
*  NO WARRANTY
*
*  10. BECAUSE THE MODULE IS LICENSED FREE OF CHARGE, THERE IS NO
*  WARRANTY FOR THE MODULE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. 
*  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS
*  AND/OR OTHER PARTIES PROVIDE THE MODULE "AS IS" WITHOUT WARRANTY OF
*  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED
*  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
*  PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND
*  PERFORMANCE OF THE MODULE IS WITH YOU.  SHOULD THE MODULE PROVE
*  DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR
*  OR CORRECTION.
*
*  11. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
*  WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY
*  MODIFY AND/OR REDISTRIBUTE THE MODULE AS PERMITTED ABOVE, BE LIABLE
*  TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
*  CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
*  THE MODULE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
*  RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR
*  A FAILURE OF THE MODULE TO OPERATE WITH ANY OTHER MODULES), EVEN IF
*  SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
*  SUCH DAMAGES.
*
*  END OF TERMS AND CONDITIONS
***************************************************************************/

#include "..\h\p33FJ256GP506.h"
#include "..\h\WM8510CodecDrv.h"
#include "..\h\sask.h"
#include "..\h\SFMDrv.h"

#include "..\h\G726A.h"
#include "..\h\G726APack.h"

/* Disable clock write protection
 * Select Primary osc w/ PLL
 * Clock switch enabled, OSC2 Pin digital I/O, external clock (12 MHZ)
 * Watchdog Time disabled
 */
_FGS(GWRP_OFF & GCP_OFF);
_FOSCSEL(FNOSC_PRIPLL);
_FOSC(FCKSM_CSECMD & OSCIOFNC_ON & POSCMD_EC);
_FWDT(FWDTEN_OFF);

/* SPEECH_SEGMENT_SIZE - Size of intro speech segment
 * WRITE_START_ADDRESS - Serial Flash Memory write address
 * PACKED_BYTES - The number of bytes contained in G726A
 *                 packed data array					
 */
#define SPEECH_SEGMENT_SIZE 29184L
#define WRITE_START_ADDRESS	0x20000
#define PACKED_BYTES 20
/* Allocate state memory and IO buffers for G.726A encoder and decoder */
int rawSamples	[G726A_FRAME_SIZE]; 
int decodedSamples [G726A_FRAME_SIZE];
unsigned char encodedSamples[G726A_FRAME_SIZE];
unsigned char packedData[G726A_FRAME_SIZE];
unsigned char encoder[G726A_ENCODER_SIZE];
unsigned char decoder[G726A_DECODER_SIZE];

/*FOR TESTING PURPOSES ONLY
 *array to store the packedBytes values of each sample.
 */
int bytesPerFrame[500];

/* Allocate memory for buffers and drivers
 * codecBuffer - Buffer used by the codec driver
 * flashMemoryBuffer - buffer used by the SFM driver
 * */
int 	codecBuffer		[WM8510DRV_DRV_BUFFER_SIZE];
char 	flashMemoryBuffer	[SFMDRV_BUFFER_SIZE];

WM8510Handle codec;
WM8510Handle * codecHandle = &codec;
SST25VF040BHandle flashMemoryHandle; 

/* Addresses 
 * currentReadAddress - This one tracks the intro message	
 * currentWriteAddress - This one tracks the writes to flash	
 * userPlaybackAddress - This one tracks user playback		
 * address - Used during flash erase
 * */

long currentReadAddress;		
long currentWriteAddress;		
long userPlaybackAddress;		
long address;

/* flags
 * record - if set means recording
 * playback - if set mean playback
 * erasedBeforeRecord - means SFM eras complete before record
 * */

int record;						
int playback;					
int erasedBeforeRecord;	

int main(void)
{
	/* Addresses 
	 * currentReadAddress - This one tracks the intro message	
	 * currentWriteAddress - This one tracks the writes to flash	
	 * userPlaybackAddress - This one tracks user playback		
	 * address - Used during flash erase
	 * */

	long currentReadAddress = 0;		
	long currentWriteAddress = WRITE_START_ADDRESS;		
	long userPlaybackAddress = WRITE_START_ADDRESS;		
	long address = 0;							

	/* flags
	 * record - if set means recording
	 * playback - if set mean playback
	 * erasedBeforeRecord - means SFM eras complete before record
	 * */

	int record = 0;						
	int playback = 0;					
	int erasedBeforeRecord = 0;

	/* index values */
	unsigned char i;
	int j = 0;	/* FOR TESTING PURPOSES ONLY */
	
	/* packedBytes is the number of bytes returned
     * by G726APack() and input for G726AUnpack() */ 
	int packedBytes;

	/* Configure Oscillator to operate the device at 80MHz / 40 MIPS.
	 * Fosc= Fin*M/(N1*N2), Fcy=Fosc/2
	 * Fosc= 12M*40/(3*4)=40Mhz for 12MHz input clock */
 
	PLLFBD=38;				/* M = PLLFBD + 2 = 40	*/
	CLKDIVbits.PLLPRE=1;	/* N1 = PLLPRE + 2 = 3	*/
	CLKDIVbits.PLLPOST=0;	/* N2 = PLLPOST + 2 = 4	*/
	OSCTUN=0;			
	
	__builtin_write_OSCCONH(0x01);		/*	Initiate Clock Switch to FRC with PLL*/
	__builtin_write_OSCCONL(0x01);
	while (OSCCONbits.COSC != 0b01);	/*	Wait for Clock switch to occur	*/
	while(!OSCCONbits.LOCK);

	/* Intialize the board and the drivers	*/
	SASKInit();
	WM8510Init(codecHandle,codecBuffer);
	
	/* Open the flash and unprotect it so that
	 * it can be written to.
	 * */
	SFMInit(flashMemoryBuffer);

	/* Start Audio input and output function	*/
	WM8510Start(codecHandle);
		
	/* Configure codec for 8K operation	*/
	WM8510SampleRate8KConfig(codecHandle);

	/* Initialize G.726A Encoder and Decoder. */
	G726AEncoderInit(encoder, G726A_16KBPS, G726A_FRAME_SIZE);
	G726ADecoderInit(decoder, G726A_16KBPS, G726A_FRAME_SIZE);

	/* Main processing loop. Executed for every input and 
	 * output frame	*/
	while(1)
	{
		/*Obtain Audio Samples	*/
		while(WM8510IsReadBusy(codecHandle));
		WM8510Read(codecHandle, rawSamples, G726A_FRAME_SIZE);

		/* Playback the intro message if record or play functions 
		 * are not active. Read SFM from address 0 where the intro
		 * message is stored. Rewind the currentReadAddress if the
		 * message has reached the end.
		 * */
		
		if(!record && !playback)
		{	
			currentReadAddress += SFMRead(currentReadAddress, 
				encodedSamples, G726A_FRAME_SIZE);
			if(currentReadAddress >= SPEECH_SEGMENT_SIZE)
			{
				currentReadAddress = 0;
			}

			/* Decode the samples	*/
			G726ADecode(decoder, encodedSamples, decodedSamples);
			
			for(i = 0; i < G726A_FRAME_SIZE; i ++)
        	{
	            /* Scale the decoded sample to 
	             * adjust for the 16 to 14-bit scaling done before
	             * encode */
	            decodedSamples[i] = decodedSamples[i] << 2;
			}

			/* Wait till the codec is available for a new  frame	*/
			while(WM8510IsWriteBusy(codecHandle));	
		
			/* Write the frame to the output	*/
			WM8510Write (codecHandle, decodedSamples, G726A_FRAME_SIZE);		
		}

		/* If record is enabled, encode the samples using G711. 
		 * Store in flash. Erase flash before recording starts	*/
		if(record == 1)
		{
			if(erasedBeforeRecord == 0)
			{
				/* Stop the Audio input and output since this is a blocking
				 * operation. Also rewind record and playback pointers to
				 * start of the user flash area. Erase the user side of 
				 * SFM memory blocks. Also set the erasedBeforeRecord flag
				 * so that this is done only once before record. Start the
				 * codec when the erase is complete.
				 * */				 
				WM8510Stop(codecHandle);
				currentWriteAddress = WRITE_START_ADDRESS;
				userPlaybackAddress = WRITE_START_ADDRESS;
				RED_LED = SASK_LED_ON;
				YELLOW_LED = SASK_LED_OFF;
			
				for(address = WRITE_START_ADDRESS; 
						address < SFM_LAST_ADDRESS;
					   	address += 0x10000)
				{
					SFMBlockErase(address);
					
				}
				RED_LED = SASK_LED_OFF;		
				 
				erasedBeforeRecord = 1;
				WM8510Start(codecHandle);
			}
			else
			{	
				/* Record the encoded audio frame. Yellow LED turns on when
				 * when recording is being performed. Store the encoded
				 * buffer into SFM. If the last SFM address is reached then
				 * stop recording and start playback.
				 * */
				
				YELLOW_LED = SASK_LED_ON;

			    for(i = 0; i < G726A_FRAME_SIZE; i ++)
			    {
			        // Not necessary if its known that input
			        // is 14 bits or less.			
			        rawSamples[i] = rawSamples[i] >> 2;
			    }

        		G726AEncode(encoder,rawSamples,encodedSamples);
				
				packedBytes = G726APack(encodedSamples, packedData, G726A_FRAME_SIZE, G726A_16KBPS);

				/* Causes compile warning due to passing unsigned char* to char* argument */
				currentWriteAddress += SFMWrite(currentWriteAddress,
							encodedSamples, packedBytes);
			
				/*FOR TESTING PURPOSES ONLY - record byte size of packedData per Frame */
				bytesPerFrame[j] = packedBytes;
				j++;

				if(currentWriteAddress >= SFM_LAST_ADDRESS)
				{
				
					YELLOW_LED = SASK_LED_OFF;
					erasedBeforeRecord = 0;
					record = 0;
					playback = 1;
				}
			}
				
		}	/* End of record branch */
		
		/* If playback is enabled, then start playing back samples from the
		 * user area. Playback only till the last record address and then 
		 * rewind to the start	*/
		 
		if(playback == 1)
		{
			GREEN_LED = SASK_LED_ON;
			erasedBeforeRecord = 0;		

			/* Causes compile warning due to passing unsigned char* to char* argument */
			userPlaybackAddress += SFMRead(userPlaybackAddress,
							encodedSamples, G726A_FRAME_SIZE);
			
			if(userPlaybackAddress >= currentWriteAddress)
			{
				userPlaybackAddress = WRITE_START_ADDRESS;
			}

			G726AUnpack(packedData, encodedSamples, G726A_FRAME_SIZE, G726A_16KBPS);

			/* Decode the samples	*/
			G726ADecode(decoder, encodedSamples, decodedSamples);

			unsigned char i;
			for(i = 0; i < G726A_FRAME_SIZE; i ++)
        	{
	            /* Scale the decoded sample to 
	             * adjust for the 16 to 14-bit scaling done before
	             * encode */
	            decodedSamples[i] = decodedSamples[i] << 2;
			}

			/* Wait till the codec is available for a new  frame	*/
			while(WM8510IsWriteBusy(codecHandle));	
		
			/* Write the frame to the output	*/
			WM8510Write (codecHandle,decodedSamples,G726A_FRAME_SIZE);
		
		}

		/* The CheckSwitch functions are defined in sask.c	*/
		
		if((CheckSwitchS1()) == 1)
		{
			/* Toggle the record function and Yellow led.
			 * Rewind the intro message playback pointer. 
			 * And if recording, disable playback.
			 * */
			 
			
			record =1;				
			currentReadAddress = 0;	
			erasedBeforeRecord = 0;
			if(record == 1)
			{
				playback = 0;
				GREEN_LED = SASK_LED_OFF;

			}
			else
			{
				YELLOW_LED = SASK_LED_OFF;
			}
		}
		
		
		if((CheckSwitchS2()) == 1)
		{
			/* Toggle the record function and AMBER led.
			 * Rewind the intro message playback pointer. 
			 * And if recording, disable playback.
			 * */
			 
			GREEN_LED ^=1;
			playback =1 ;
			userPlaybackAddress = WRITE_START_ADDRESS;
			currentReadAddress = 0;		
			if(playback == 1)
			{
				record = 0;
				YELLOW_LED = SASK_LED_OFF;
			}
		}
	
	}	/* End of main processing loop */

}	/* End of main() */
