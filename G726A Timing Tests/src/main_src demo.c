/**************************************************************************
*  
*             ITU-T SOFTWARE TOOLS' GENERAL PUBLIC LICENSE                  
*
*  This "General Public License" is published in the Annex 1 of the
*  ITU-T Recommendation on "SOFTWARE TOOLS FOR HOMOGENITY OF RESULTS
*  IN THE STANDARDIZATION PROCESS OF SPEECH AND AUDIO CODERS",
*  approved in Geneva, 2000.
*
*  TERMS AND CONDITIONS
*
*  1. This License Agreement applies to any module or other work
*  related to the ITU-T Software Tool Library, and developed by the
*  User's Group on Software Tools. The "Module", below, refers to any
*  such module or work, and a "work based on the Module" means either
*  the Module or any work containing the Module or a portion of it,
*  either verbatim or with modifications.  Each licensee is addressed
*  as "you".
*
*  2. You may copy and distribute verbatim copies of the Module's
*  source code as you receive it, in any medium, provided that you:
*  -  conspicuously and appropriately publish on each copy an appropriate
*     copyright notice and disclaimer of warranty;
*  -  keep intact all the notices that refer to this General Public
*     License and to the absence of any warranty; and
*  -  give any other recipients of the Module a copy of this General
*     Public License along with the Module.
*  You may charge a fee for the physical act of transferring a copy.
*
*  3. You may modify your copy or copies of the Module or any portion
*  of it, and copy and distribute such modifications under the terms
*  of Paragraph 1 above, provided that you also do the following:
*
*      o  cause the modified files to carry prominent notices stating
*      that you changed the files and the date of any change; and
*
*      o  cause the whole of any work that you distribute or publish,
*      that in whole or in part contains the Module or any part
*      thereof, either with or without modifications, to be licensed
*      at no charge to all third parties under the terms of this
*      General Public License (except that you may choose to grant
*      warranty protection to some or all third parties, at your
*      option).
*
*      o  If the modified module normally reads commands interactively
*      when run, you must cause it, when started running for such
*      interactive use in the simplest and most usual way, to print or
*      display an announcement including an appropriate copyright
*      notice and a notice that there is no warranty (or else, saying
*      that you provide a warranty) and that users may redistribute
*      the module under these conditions, and telling the user how to
*      view a copy of this General Public License.
*
*  You may charge a fee for the physical act of transferring a copy,
*  and you may at your option offer warranty protection in exchange
*  for a fee.
*
*  Mere aggregation of another independent work with the Module (or
*  its derivative) on a volume of a storage or distribution medium
*  does not bring the other work under the scope of these terms.
*
*  4.  You may copy and distribute the Module (or a portion or
*  derivative of it, under Paragraph 2) in object code or executable
*  form under the terms of Paragraphs 1 and 2 above provided that you
*  also do one of the following:
*
*      o  accompany it with the complete corresponding machine-
*      readable source code, which must be distributed under the terms
*      of Paragraphs 1 and 2 above; or,
*
*      o  accompany it with a written offer, valid for at least three
*      years, to give any third party free (except for a nominal
*      charge for the cost of distribution) a complete machine-
*      readable copy of the corresponding source code, to be
*      distributed under the terms of Paragraphs 1 and 2 above; or,
*
*      o  accompany it with the information you received as to where
*      the corresponding source code may be obtained.  (This
*      alternative is allowed only for noncommercial distribution and
*      only if you received the module in object code or executable
*      form alone.) 
*
*  Source code for a work means the preferred form of the work for
*  making modifications to it.  For an executable file, complete
*  source code means all the source code for all modules it contains;
*  but, as a special exception, it need not include source code for
*  modules which are standard libraries that accompany the operating
*  system on which the executable file runs, or for standard header
*  files or definitions files that accompany that operating system.
*
*  5.  You may not copy, modify, sublicense, distribute or transfer
*  the Module except as expressly provided under this General Public
*  License. Any attempt otherwise to copy, modify, sublicense,
*  distribute or transfer the Module is void, and will automatically
*  terminate your rights to use the Module under this License. 
*  However, parties who have received copies, or rights to use copies,
*  from you under this General Public License will not have their
*  licenses terminated so long as such parties remain in full
*  compliance.
*
*  6.  By copying, distributing or modifying the Module (or any work
*  based on the Module) you indicate your acceptance of this license
*  to do so, and all its terms and conditions.
*
*  7.  Each time you redistribute the Module (or any work based on the
*  Module), the recipient automatically receives a license from the
*  original licensor to copy, distribute or modify the Module subject
*  to these terms and conditions.  You may not impose any further
*  restrictions on the recipients' exercise of the rights granted
*  herein.
*
*  8.  The ITU-T may publish revised and/or new versions of this
*  General Public License from time to time.  Such new versions will
*  be similar in spirit to the present version, but may differ in
*  detail to address new problems or concerns.
*
*  Each version is given a distinguishing version number. If the
*  Module specifies a version number of the license which applies to
*  it and "any later version", you have the option of following the
*  terms and conditions either of that version or of any later version
*  published by the ITU-T. If the Module does not specify a version
*  number of the license, you may choose any version ever published by
*  the ITU-T.
*
*  9.  If you wish to incorporate parts of the Module into other free
*  modules whose distribution conditions are different, write to the
*  author to ask for permission.  For software which is copyrighted by
*  the ITU-T, write to the ITU-T Secretariat; exceptions may be made
*  for this. This decision will be guided by the two goals of
*  preserving the free status of all derivatives of this free software
*  and of promoting the sharing and reuse of software generally.
*
*
*  NO WARRANTY
*
*  10. BECAUSE THE MODULE IS LICENSED FREE OF CHARGE, THERE IS NO
*  WARRANTY FOR THE MODULE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. 
*  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS
*  AND/OR OTHER PARTIES PROVIDE THE MODULE "AS IS" WITHOUT WARRANTY OF
*  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED
*  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
*  PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND
*  PERFORMANCE OF THE MODULE IS WITH YOU.  SHOULD THE MODULE PROVE
*  DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR
*  OR CORRECTION.
*
*  11. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
*  WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY
*  MODIFY AND/OR REDISTRIBUTE THE MODULE AS PERMITTED ABOVE, BE LIABLE
*  TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
*  CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
*  THE MODULE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
*  RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR
*  A FAILURE OF THE MODULE TO OPERATE WITH ANY OTHER MODULES), EVEN IF
*  SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
*  SUCH DAMAGES.
*
*  END OF TERMS AND CONDITIONS
***************************************************************************/


    #include <p33Fxxxx.h>
	#include "..\h\Explorer16.h"
	#include "..\h\WM8510CodecDrv.h"
	#include "..\h\SST25VF040BDrv.h"

#include "..\h\G726A.h"
#include "..\h\G726APack.h"

	_FGS(GWRP_OFF & GCP_OFF);
	_FOSCSEL(FNOSC_FRC);
	_FOSC(FCKSM_CSECMD & OSCIOFNC_ON & POSCMD_XT);
	_FWDT(FWDTEN_OFF);


/* Allocate state memory and IO buffers for G.726A encoder and decoder */
int samples	[G726A_FRAME_SIZE]; 
int decodedSamples [G726A_FRAME_SIZE];
unsigned char encodedSamples[G726A_FRAME_SIZE];
unsigned char packedData[G726A_FRAME_SIZE];
unsigned char encoder[G726A_ENCODER_SIZE];
unsigned char decoder[G726A_DECODER_SIZE];

/* Allocate memory for buffers and drivers	*/
	int codecBuffer [WM8510DRV_DRV_BUFFER_SIZE] ;
	WM8510Handle codec;
	WM8510Handle * codecHandle = &codec;

/* Allocate buffers for the Serial flash memory and instantiate a
 * handle to the driver state	*/
	unsigned char flashMemoryBuffer[SST25VF040BDRV_BUFFER_SIZE];
	SST25VF040BHandle flashMemoryHandle; 
	SST25VF040BHandle *pFlashMemoryHandle = &flashMemoryHandle;

int main(void)
{
    long currentWriteAddress;   /* This variable tracks the writes to flash	*/
    long userPlaybackAddress;	/* This variable tracks user playback		*/
    int record;					/* If set, indicates recording is in progress */
    int playback;				/* If set, indicates playback is in progress */
    int erasedBeforeRecord;		/* If set, indicates erase before record is complete */
    int commandValue = 0;		/* This command value un-protects the flash */
    int i;
    int nPackedBytes;

    /* Configure Oscillator to operate the device at 40MHz.
     * Fosc= Fin*M/(N1*N2), Fcy=Fosc/2
     * Fosc= 8.0M*40/(2*2)=80Mhz for 8.0M input clock */
    PLLFBD=38;				/* M=40	*/
    CLKDIVbits.PLLPOST=0;		/* N1=2	*/
    CLKDIVbits.PLLPRE=0;		/* N2=2	*/
    OSCTUN=0;			
    __builtin_write_OSCCONH(0x03);		/*	Initiate Clock Switch to FRC with PLL*/
    __builtin_write_OSCCONL(0x01);
    while (OSCCONbits.COSC != 0b011);	/*	Wait for Clock switch to occur	*/
    while(!OSCCONbits.LOCK);	

    /* Initialize flags and address variables	*/
    record 				= 0;
    playback 			= 0;
    currentWriteAddress	= 0;
    userPlaybackAddress	= 0;
    erasedBeforeRecord 	= 0;	

    /* Initialise the flash driver. Enable status write and unprotect the device */
    /* Refer to the device data sheet for more details	*/
    SST25VF040BInit	(pFlashMemoryHandle,flashMemoryBuffer);	
   	SST25VF040BStart(pFlashMemoryHandle);
   	SST25VF040BIOCtl(pFlashMemoryHandle, SST25VF040BDRV_WRITE_STATUS_ENABLE,0);
   	SST25VF040BIOCtl(pFlashMemoryHandle, SST25VF040BDRV_WRITE_STATUS,(void *)&commandValue);

    /* Intialize the G.726A Encoder and Decoder.*/ 
    G726AEncoderInit(encoder,G726A_40KBPS, G726A_FRAME_SIZE);
    G726ADecoderInit(decoder,G726A_40KBPS, G726A_FRAME_SIZE);

    /* Intialize the codec driver state, start it
     * and configure the codec for 8KHz sample rate */
	Explorer16Init();
	WM8510Init(codecHandle, codecBuffer);
	WM8510Start(codecHandle);
	WM8510SampleRate8KConfig(codecHandle);

    /* Main processing loop. Executed for every input and 
     * output frame. 
     * 1. Capture speech and encode
     * 2. Erase and record if record = 1
     * 3. Playback if playback = 1
     * 4. Check switch S3 and set record if activated
     * 5. Check switch S4 and set playback if activated
     * 6. Goto 1	*/
    while(1)
    {

/* LED3 - This indicates that the application is running
 * LED4 - This indicates that the flash is being erased
 * LED7 - This indicates that application is recording
 * LED8 - This indicates that application is playing back */
		LED3 = EXPLORER16_LED_ON;

        /* Obtaing the audio samples	*/
        while(WM8510IsReadBusy(codecHandle));
        WM8510Read(codecHandle,samples,G726A_FRAME_SIZE);

        for(i = 0; i < G726A_FRAME_SIZE; i++)
        {
            /* Adjust the input so that it
             * is 14 bit */
            samples[i] = samples[i] >> 2;
        }

        /* Encode the voice data */
        G726AEncode(encoder,samples,encodedSamples);
        
        /* Pack the encoded samples */
        nPackedBytes = G726APack(encodedSamples, packedData, G726A_FRAME_SIZE, G726A_40KBPS);		

        /* If record is enabled, encode the samples using G.726A  
         * Store in flash. Erase flash before recording starts	*/
        if(record == 1)
        {				
            if(erasedBeforeRecord == 0)
            {
                /* Stop the Audio input and output since this is a blocking
                 * operation. Also rewind record and playback pointers to
                 * start of the user flash area.*/
                LED4 = EXPLORER16_LED_ON;
                WM8510Stop(codecHandle);

				/* Reset addresses */
                currentWriteAddress = 0;
                userPlaybackAddress = 0;

                /* Erase the  flash. */
                SST25VF040BIOCtl(pFlashMemoryHandle, SST25VF040BDRV_WRITE_ENABLE,0);
                SST25VF040BIOCtl(pFlashMemoryHandle, SST25VF040BDRV_CHIP_ERASE,0);

                /* Since erase is complete, the next time the loop is executed
                 * do not erase the flash. Start the audio input and output	*/
                erasedBeforeRecord = 1;

                WM8510Start(codecHandle);
                LED4 = EXPLORER16_LED_OFF;
            }
            else
            {	
                /* Record the encoded audio frame. */

				/* LED7 turns on when when recording is being performed	*/
                LED7 = EXPLORER16_LED_ON;
                while( SST25VF040BIsBusy(pFlashMemoryHandle));
                SST25VF040BIOCtl(pFlashMemoryHandle, SST25VF040BDRV_WRITE_ENABLE,0);
                SST25VF040BWrite(pFlashMemoryHandle, currentWriteAddress, packedData, nPackedBytes);
                currentWriteAddress += nPackedBytes;
                if(currentWriteAddress >= SST25VF040BDRV_LAST_ADDRESS)
                {
                    /* If flash is full then stop recording and start playing back	*/
                    LED7 = EXPLORER16_LED_OFF;
                    LED8 = EXPLORER16_LED_ON;
                    record = 0;
                    playback = 1;
                    erasedBeforeRecord = 0;
                }
            }
        } /* End of Frame Record */

        if(playback == 1)
        {
            /* If playback is enabled, then start playing back samples from 
             * address 0. Playback only till the last record address and then 
             * rewind to the start	*/
            while( SST25VF040BIsBusy(pFlashMemoryHandle));				
            SST25VF040BRead(pFlashMemoryHandle,userPlaybackAddress,packedData,nPackedBytes);
            while( SST25VF040BIsBusy(pFlashMemoryHandle));

            userPlaybackAddress += nPackedBytes;
            if(userPlaybackAddress >= currentWriteAddress)
            {
                /* Cannot playback more than what is recorded, so rewind pointer */
                userPlaybackAddress = 0;
            }
        } /* End of Frame Playback */
        
        /* Unpack the data */
        G726AUnpack(packedData, encodedSamples, G726A_FRAME_SIZE, G726A_40KBPS);

        /* Decode the samples	*/
        G726ADecode(decoder, encodedSamples, decodedSamples);

        for(i = 0; i < G726A_FRAME_SIZE; i ++)
        {
            /* Re-adjust the decoded sample to 
             * adjust for the scaling done before
             * encode */
            decodedSamples[i] = decodedSamples[i] << 2;
        }

        /* Wait till the codec is available for a new  frame	
         * and then write to the codec */
        while(WM8510IsWriteBusy(codecHandle));	
        WM8510Write (codecHandle,decodedSamples,G726A_FRAME_SIZE);

        /* The CheckSwitch functions are defined in Explorer16.c	*/			
        if((CheckSwitchS3()) == 1)
        {
            /* Set the record flag, clear the playback  flag
             * switch off LED6, switch on LED5 */

            playback  = 0;
            record = 1;
			LED7 = EXPLORER16_LED_ON;
            LED8 = EXPLORER16_LED_OFF;
        }
        if((CheckSwitchS6()) == 1)
        {
            /* Set the playback flag, clear the recording flag
             * switch off LED5, switch on LED6, clear the erasedBeforeRecord
             * flag to erase the flash the next time record is pressed */

            playback  = 1;
            record = 0;
            erasedBeforeRecord = 0;
            LED7 = EXPLORER16_LED_OFF;
            LED8 = EXPLORER16_LED_ON;
        }		
    } /* End of while loop */
} /* End of main */
