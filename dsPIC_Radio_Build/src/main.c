/**************************************************************************
*  
*             ITU-T SOFTWARE TOOLS' GENERAL PUBLIC LICENSE                  
*
*  This "General Public License" is published in the Annex 1 of the
*  ITU-T Recommendation on "SOFTWARE TOOLS FOR HOMOGENITY OF RESULTS
*  IN THE STANDARDIZATION PROCESS OF SPEECH AND AUDIO CODERS",
*  approved in Geneva, 2000.
*
*  TERMS AND CONDITIONS
*
*  1. This License Agreement applies to any module or other work
*  related to the ITU-T Software Tool Library, and developed by the
*  User's Group on Software Tools. The "Module", below, refers to any
*  such module or work, and a "work based on the Module" means either
*  the Module or any work containing the Module or a portion of it,
*  either verbatim or with modifications.  Each licensee is addressed
*  as "you".
*
*  2. You may copy and distribute verbatim copies of the Module's
*  source code as you receive it, in any medium, provided that you:
*  -  conspicuously and appropriately publish on each copy an appropriate
*     copyright notice and disclaimer of warranty;
*  -  keep intact all the notices that refer to this General Public
*     License and to the absence of any warranty; and
*  -  give any other recipients of the Module a copy of this General
*     Public License along with the Module.
*  You may charge a fee for the physical act of transferring a copy.
*
*  3. You may modify your copy or copies of the Module or any portion
*  of it, and copy and distribute such modifications under the terms
*  of Paragraph 1 above, provided that you also do the following:
*
*      o  cause the modified files to carry prominent notices stating
*      that you changed the files and the date of any change; and
*
*      o  cause the whole of any work that you distribute or publish,
*      that in whole or in part contains the Module or any part
*      thereof, either with or without modifications, to be licensed
*      at no charge to all third parties under the terms of this
*      General Public License (except that you may choose to grant
*      warranty protection to some or all third parties, at your
*      option).
*
*      o  If the modified module normally reads commands interactively
*      when run, you must cause it, when started running for such
*      interactive use in the simplest and most usual way, to print or
*      display an announcement including an appropriate copyright
*      notice and a notice that there is no warranty (or else, saying
*      that you provide a warranty) and that users may redistribute
*      the module under these conditions, and telling the user how to
*      view a copy of this General Public License.
*
*  You may charge a fee for the physical act of transferring a copy,
*  and you may at your option offer warranty protection in exchange
*  for a fee.
*
*  Mere aggregation of another independent work with the Module (or
*  its derivative) on a volume of a storage or distribution medium
*  does not bring the other work under the scope of these terms.
*
*  4.  You may copy and distribute the Module (or a portion or
*  derivative of it, under Paragraph 2) in object code or executable
*  form under the terms of Paragraphs 1 and 2 above provided that you
*  also do one of the following:
*
*      o  accompany it with the complete corresponding machine-
*      readable source code, which must be distributed under the terms
*      of Paragraphs 1 and 2 above; or,
*
*      o  accompany it with a written offer, valid for at least three
*      years, to give any third party free (except for a nominal
*      charge for the cost of distribution) a complete machine-
*      readable copy of the corresponding source code, to be
*      distributed under the terms of Paragraphs 1 and 2 above; or,
*
*      o  accompany it with the information you received as to where
*      the corresponding source code may be obtained.  (This
*      alternative is allowed only for noncommercial distribution and
*      only if you received the module in object code or executable
*      form alone.) 
*
*  Source code for a work means the preferred form of the work for
*  making modifications to it.  For an executable file, complete
*  source code means all the source code for all modules it contains;
*  but, as a special exception, it need not include source code for
*  modules which are standard libraries that accompany the operating
*  system on which the executable file runs, or for standard header
*  files or definitions files that accompany that operating system.
*
*  5.  You may not copy, modify, sublicense, distribute or transfer
*  the Module except as expressly provided under this General Public
*  License. Any attempt otherwise to copy, modify, sublicense,
*  distribute or transfer the Module is void, and will automatically
*  terminate your rights to use the Module under this License. 
*  However, parties who have received copies, or rights to use copies,
*  from you under this General Public License will not have their
*  licenses terminated so long as such parties remain in full
*  compliance.
*
*  6.  By copying, distributing or modifying the Module (or any work
*  based on the Module) you indicate your acceptance of this license
*  to do so, and all its terms and conditions.
*
*  7.  Each time you redistribute the Module (or any work based on the
*  Module), the recipient automatically receives a license from the
*  original licensor to copy, distribute or modify the Module subject
*  to these terms and conditions.  You may not impose any further
*  restrictions on the recipients' exercise of the rights granted
*  herein.
*
*  8.  The ITU-T may publish revised and/or new versions of this
*  General Public License from time to time.  Such new versions will
*  be similar in spirit to the present version, but may differ in
*  detail to address new problems or concerns.
*
*  Each version is given a distinguishing version number. If the
*  Module specifies a version number of the license which applies to
*  it and "any later version", you have the option of following the
*  terms and conditions either of that version or of any later version
*  published by the ITU-T. If the Module does not specify a version
*  number of the license, you may choose any version ever published by
*  the ITU-T.
*
*  9.  If you wish to incorporate parts of the Module into other free
*  modules whose distribution conditions are different, write to the
*  author to ask for permission.  For software which is copyrighted by
*  the ITU-T, write to the ITU-T Secretariat; exceptions may be made
*  for this. This decision will be guided by the two goals of
*  preserving the free status of all derivatives of this free software
*  and of promoting the sharing and reuse of software generally.
*
*
*  NO WARRANTY
*
*  10. BECAUSE THE MODULE IS LICENSED FREE OF CHARGE, THERE IS NO
*  WARRANTY FOR THE MODULE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. 
*  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS
*  AND/OR OTHER PARTIES PROVIDE THE MODULE "AS IS" WITHOUT WARRANTY OF
*  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED
*  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
*  PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND
*  PERFORMANCE OF THE MODULE IS WITH YOU.  SHOULD THE MODULE PROVE
*  DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR
*  OR CORRECTION.
*
*  11. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
*  WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY
*  MODIFY AND/OR REDISTRIBUTE THE MODULE AS PERMITTED ABOVE, BE LIABLE
*  TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
*  CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
*  THE MODULE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
*  RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR
*  A FAILURE OF THE MODULE TO OPERATE WITH ANY OTHER MODULES), EVEN IF
*  SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
*  SUCH DAMAGES.
*
*  END OF TERMS AND CONDITIONS
***************************************************************************/

#include "..\h\includes.h"


#if defined USE_SFM_CHIP
#include "..\h\SFMDrv.h"
#define FRAME_SIZE 				80		
#define SPEECH_SEGMENT_SIZE		29184L	
#define WRITE_START_ADDRESS	0x20000
#endif


/* Disable clock write protection
 * Select Primary OSC w/ PLL
 * Clock switch enabled, OSC2 Pin digital I/O, external clock (12 MHZ)
 * Watchdog Time disabled
 */
_FGS(GWRP_OFF & GCP_OFF);
_FOSCSEL(FNOSC_PRIPLL);
_FOSC(FCKSM_CSECMD & OSCIOFNC_ON & POSCMD_EC);
_FWDT(FWDTEN_OFF);

/******* Private variable declarations *******/
/* PACKED_BYTES - The number of bytes contained in G726A
 *                 packed data array					
 */
#define PACKED_BYTES 20

/* Allocate state memory and IO buffers for G.726A encoder and decoder */
int rawSamples		[G726A_FRAME_SIZE]; 
int decodedSamples	[G726A_FRAME_SIZE];
unsigned char encodedSamples[G726A_FRAME_SIZE];
unsigned char packedData[PACKED_BYTES];
unsigned char encoder[G726A_ENCODER_SIZE];
unsigned char decoder[G726A_DECODER_SIZE];

#if defined USE_SFM_CHIP
char 	flashMemoryBuffer	[SFMDRV_BUFFER_SIZE];
SST25VF040BHandle flashMemoryHandle; 


/* Addresses 
 * currentReadAddress - This one tracks the intro message	
 * currentWriteAddress - This one tracks the writes to flash	
 * userPlaybackAddress - This one tracks user playback		
 * address - Used during flash erase
 * */

/*USE_SFM_CHIP */
long currentReadAddress;		
long currentWriteAddress;		
long userPlaybackAddress;		
long address;	
int erasedBeforeRecord;
#endif


/* Allocate memory for buffers and drivers
 * codecBuffer - Buffer used by the codec driver
 * flashMemoryBuffer - buffer used by the SFM driver
 * */
int 	codecBuffer		[WM8510DRV_DRV_BUFFER_SIZE];

WM8510Handle codec;
WM8510Handle * codecHandle = &codec;

/* taskID - Returned value from last SCH_addTask() call.
 * 			Used for SCH_deleteTask()
 * transceiverReady - Set FALSE to prevent SYNC_CLK
			output until CC430 is initialized.
 * modeFlag - Indicates if CC430 is placing dsPIC in 
 * 			record, playback or idle mode.
 * currentMode - Indicates the mode of hte dsPIC until 
 *			the next mode check with CC430.
 */
int taskID;
int transceiverReady = FALSE;

enum modes 	modeFlag;
enum modes	currentMode;

/* Index values */

/******* Function Declarations *******/
void audioCodecInit();
void changeCodecSampling();
void modeSelect();
void encodeData();
void readCodec();
void decodeData();
void writeCodec();
void writeToSPI();
void readFromSPI();

int main(void) {

#if defined USE_SFM_CHIP
/* Addresses 
 * currentReadAddress - This one tracks the intro message	
 * currentWriteAddress - This one tracks the writes to flash	
 * userPlaybackAddress - This one tracks user playback		
 * address - Used during flash erase
 * */
long currentReadAddress = 0;		
long currentWriteAddress = WRITE_START_ADDRESS;		
long userPlaybackAddress = WRITE_START_ADDRESS;		
long address = 0;							

/* flags
 * record - if set means recording
 * playback - if set mean playback
 * erasedBeforeRecord - means SFM eras complete before record
 * */
int record = 0;						
int playback = 0;					
int erasedBeforeRecord = 0;	
#endif

	/* Run initialization functions */	
	INIT_init();
	audioCodecInit();

#if defined USE_SFM_CHIP
SFMInit(flashMemoryBuffer);
#endif

	/* In order to ensure the pre-emptive tasks are placed in 
	 * location 0 during mode selection, the modeSelect task
	 * is added twice. The first iteration in location 0 will 
	 * be replaced by pre-emptive.
	 */
	SCH_addTask(WM8510IdleSampling, 1, 0, CO_OP);
	SCH_addTask(modeSelect, DELAY_MODE_SELECT, FRAME_PERIOD, CO_OP);
	
	/* After initialization, wait until CC430 pulls both
     * mode flags LOW.
	 */
//	while( (PLAYBACK_FLAG || RECORD_FLAG) );

#if defined TIMING_TEST
TIMING_PULSE_TRIS = 0;
TIMING_PULSE_PIN = 0;

modeFlag = PLAYBACK;
while((CheckSwitchS1()) == 0);
#endif

	/* Once the CC430 signals it is ready, transceiver is set TRUE
	 * and synchronization pulses in SCH_UPDATES() will be sent
	 * to CC430.
	 */
	transceiverReady = TRUE;

	/* Main processing loop. */
	while(1) {
		SCH_dispatchTasks();		
	}	/* End of main processing loop */
} /* End of main() */

/******* Function Definitions *******/
/* Initialization of the WM8510 codec and G726A codec */
void audioCodecInit() {
	
	/* Initialize the codec drivers	*/
	WM8510Init(codecHandle,codecBuffer);
	
	/* Start Audio input and output function */
	WM8510Start(codecHandle);
		
	/* Configure codec for 8K operation	*/
	WM8510SampleRate8KConfig(codecHandle);

	/* Initialize G.726A Encoder and Decoder. */
	G726AEncoderInit(encoder, G726A_16KBPS, G726A_FRAME_SIZE);
	G726ADecoderInit(decoder, G726A_16KBPS, G726A_FRAME_SIZE);

} /* End of audioCodecInit() */

/* Select the audio processing mode to run*/
void modeSelect() {

	int i = 0;

#if defined TIMING_MODE_SELECT
	TIMING_PULSE_PIN ^= 1;
#endif
	
#if defined TIMING_TEST
	/* Check the switches for new operating mode */
	if( (CheckSwitchS1()) == 1 ) {
		modeFlag = PLAYBACK;
	}
	else if( (CheckSwitchS2()) == 1 ) {
		modeFlag = RECORD;
	}
#else
	/* Check the flags for new operating mode */
	if(PLAYBACK_FLAG == ACTIVE_MODE) {
		modeFlag = PLAYBACK;
	}
	else if(RECORD_FLAG == ACTIVE_MODE) {
		modeFlag = RECORD;
	}
	else {
		modeFlag = IDLE;
	}

#endif
	
	/* If operating mode has changed, delete existing tasks
	 * and add tasks for new mode. */
	if(modeFlag != currentMode) {
	
		if(modeFlag == PLAYBACK) {
			/* Toggle indicator LEDs. */		 
			YELLOW_LED = SASK_LED_OFF;
			GREEN_LED = SASK_LED_ON;
			
			/* Delete all tasks expect pre-emptive task [0]
			 * and modeSelect task [1]
			 */
			for(i=2; i < (SCH_MAX_TASKS); i++) {
				SCH_deleteTask(i);
			}

			SCH_addTask(readFromSPI, DELAY_READ_SPI, 	FRAME_PERIOD, CO_OP);
			SCH_addTask(decodeData,  DELAY_DECODE_DATA, FRAME_PERIOD, CO_OP);
			SCH_addTask(writeCodec, DELAY_WM8510WRITE, FRAME_PERIOD, CO_OP);
		}	
		else if(modeFlag == RECORD) {
			/* Toggle indicator LEDs. */		 
			YELLOW_LED = SASK_LED_ON;
			GREEN_LED = SASK_LED_OFF;
			
			/* Delete all tasks expect pre-emptive task [0]
			 * and modeSelect task [1]
			 */
			for(i=2; i < (SCH_MAX_TASKS); i++) {
				SCH_deleteTask(i);
			}
			
			SCH_addTask(readCodec, DELAY_WM8510READ,  FRAME_PERIOD, CO_OP);
			SCH_addTask(encodeData, DELAY_ENCODE_DATA, FRAME_PERIOD, CO_OP);
			SCH_addTask(writeToSPI, DELAY_WRITE_SPI,   FRAME_PERIOD, CO_OP);	
		}	
		else {
			/* Toggle indicator LEDs. */
			YELLOW_LED = SASK_LED_OFF;
			GREEN_LED = SASK_LED_OFF;
					
			/* Delete all tasks expect pre-emptive task [0]
			 * and modeSelect task [1]
			 */
			for(i=2; i < (SCH_MAX_TASKS); i++) {
				SCH_deleteTask(i);
			}
		}
		
		/* Add task to change the codec sampling mode at
		 * the end of the frame. Task does not repeat.*/
		SCH_addTask(changeCodecSampling, DELAY_CHANGE_CODEC_SAMPLING, 0, CO_OP);
		
		/* Current mode is set to new mode*/
		currentMode = modeFlag;
	}
	/* If operating mode has not change, do nothing*/
	else {
		return;
	}

#if defined TIMING_MODE_SELECT
	TIMING_PULSE_PIN ^= 1;
#endif	
} /* End of modeSelect() */

/* Change the pre-emptive task based on a new operating mode */
void changeCodecSampling() {

	/* Delete current pre-emptive task from list */
	SCH_deleteTask(0);
	
	/* Add new pre-emptive based on current operating mode*/
	if(currentMode == PLAYBACK) {
		SCH_addTask(WM8510PlaybackSampling, DELAY_PLAYBACK_SAMPLING, 0, PRE_EMPTIVE);
	}
	else if(currentMode == RECORD) {
		SCH_addTask(WM8510RecordSampling, DELAY_RECORD_SAMPLING, 0, PRE_EMPTIVE);
	}
	/* currentMode is IDLE, so there is no pre-emptive task */
	else {
		SCH_addTask(WM8510IdleSampling, DELAY_PLAYBACK_SAMPLING, 0, PRE_EMPTIVE);	
	}
} /* End of changeCodecSampling() */

/* Read new frame from codec and encode. */
void encodeData() {
				
	int i;	

	#if defined TIMING_ENCODE_DATA
		TIMING_PULSE_PIN ^= 1;
	#endif

	/*Obtain Audio Samples
	while(WM8510IsReadBusy(codecHandle));
	*/
	
	/* Wait till the codec is ready with a new frame */	
	if(WM8510IsReadBusy(codecHandle) == FALSE) {
		
		/* Scale samples from 16-bit to 14-bit */
		for(i = 0; i < G726A_FRAME_SIZE; i ++)
		{
			/* Not necessary if its known that input is 14 bits or less. */	
			rawSamples[i] = rawSamples[i] >> 2;
		}

		/* Encode samples*/
		G726AEncode(encoder,rawSamples,encodedSamples);
		
		/* Compresses 80 encoded samples into 20 bytes of data prior to transmission */
		G726APack(encodedSamples, packedData, G726A_FRAME_SIZE, G726A_16KBPS);
		
	}

#if defined TIMING_ENCODE_DATA
	TIMING_PULSE_PIN ^= 1;
#endif
} /* End of encodeData() */

/* Obtain audio samples from codec */
void readCodec() {
	WM8510Read(codecHandle, rawSamples, G726A_FRAME_SIZE);
} /* End of readCodec() */

/* Write decoded frame to codec for playback. */
void decodeData() {

	int i;	
	
	#if defined TIMING_DECODE_DATA
		TIMING_PULSE_PIN ^= 1;
	#endif
	
	/* Wait till the codec is available for a new frame	
	while(WM8510IsWriteBusy(codecHandle));	
	*/
	
	/* Wait till the codec is available for a new frame */
	if(WM8510IsWriteBusy(codecHandle) == FALSE) {
	
		/* Uncompress 20 bytes of received data into 80 encoded samples */
		G726AUnpack(packedData, encodedSamples, G726A_FRAME_SIZE, G726A_16KBPS);

		/* Decode the samples*/
		G726ADecode(decoder, encodedSamples, decodedSamples);

		/* Scale sample*/
		for(i = 0; i < G726A_FRAME_SIZE; i ++) 	{
			/* Scale the decoded sample to 
			 * adjust for the 16 to 14-bit scaling done before
			 * encode */
			decodedSamples[i] = decodedSamples[i] << 2;
		}
	}
	else {
	}

	#if defined TIMING_DECODE_DATA
		TIMING_PULSE_PIN ^= 1;
	#endif
}	/* End of decodeData() */

/* Write the frame to the output. */
void writeCodec() {
	WM8510Write(codecHandle, decodedSamples, G726A_FRAME_SIZE);
} /* End of writeCodec */

/* Transmit an array of data using SPI */
void writeToSPI() {

	#if defined TIMING_WRITE_SPI
		TIMING_PULSE_PIN ^= 1;
	#endif

	unsigned char currentByte = 0;
	
	while(currentByte < PACKED_BYTES) {
#ifndef NO_WAIT_SPI
		while(!SPI1STATbits.SPITBF);
#endif		
		SPI1BUF = packedData[currentByte];
		
		currentByte++;
	}

	#if defined TIMING_WRITE_SPI
		TIMING_PULSE_PIN ^= 1;
	#endif
} /* End of writeToSPI() */

/* Receive an array of data using SPI*/
void readFromSPI() {

	#if defined TIMING_READ_SPI
		TIMING_PULSE_PIN ^= 1;
	#endif

	unsigned char currentByte = 0;
	
	while(currentByte < PACKED_BYTES) {
#ifndef NO_WAIT_SPI
		while(!SPI1STATbits.SPIRBF);
#endif		
		packedData[currentByte] = SPI1BUF;
		
		currentByte++;
	}

	#if defined TIMING_READ_SPI
		TIMING_PULSE_PIN ^= 1;
	#endif
} /* End of readFromSPI() */

/******* End of File *******/
